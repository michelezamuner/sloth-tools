module.exports = [
  // Memory layout:
  // MEM:0x000 - MEM:0x005: address list
  // MEM:0x006 - MEM:0x01F: device table
  // MEM:0x020 - MEM:0xfwa: firmware
  // MEM:0xfwa - MEM:0xFFF: boot sector + free memory

  // initialize address list in memory
  // MEM:0x000: device table address
  // MEM:0x002: firmware address
  // MEM:0x004: boot sector address

  // set device table address, which is always MEM:0x006
  // which is the first address after the address list
  /* 0x000 */ 0x01, 0x00, 0x20, 0x06, // MOV R0 MEM:0x006
  /* 0x004 */ 0x05, 0x00, 0x20, 0x00, // WRITE R0 MEM:0x000

  // set firmware address, which is always MEM:0x020
  /* 0x008 */ 0x01, 0x00, 0x20, 0x20, // MOV R0 MEM:0x020
  /* 0x00C */ 0x05, 0x00, 0x20, 0x02, // WRITE RO MEM:0x002

  // copy firmware in memory
  // R0: current ROM address
  // R1: current memory address
  // R2: current firmware instruction / comparison result
  // Initialize current ROM address at ROM:0x000 - 2
  // so that at the first iteration it will be incremented
  // and start at ROM:0x000
  /* 0x010 */ 0x01, 0x00, 0xFF, 0xFE, // MOV R0 ROM:0x000 - 2
  // Initialize current memory address at firmware address - 2
  // for the same reason
  /* 0x014 */ 0x01, 0x01, 0x20, 0x1E, // MOV R1 MEM:0x01E
  // LOOP START
  /* 0x018 */ 0x0B, 0x00, 0x00, 0x02, // ADD R0 0x0002
  /* 0x01C */ 0x0B, 0x01, 0x00, 0x02, // ADD R1 0x0002
  // Read current firmware instruction
  /* 0x020 */ 0x04, 0x02, 0x00, 0x00, // READ R2 R0
  // Write current firmware instruction to memory
  /* 0x024 */ 0x06, 0x01, 0x02, 0x00, // WRITE R1 R2
  // Go to beginning of the loop if we didn't copy all instructions
  /* 0x028 */ 0x02, 0x02, 0x00, 0x00, // MOV R2 R0
  /* 0x02C */ 0x0F, 0x02, 0x00, 0xBE, // CMP R2 ROM:0x0BA
  /* 0x030 */ 0x15, 0x02, 0x00, 0x18, // JL R2 ROM:0x018

  // set free memory address, which is just after firmware
  /* 0x034 */ 0x0B, 0x01, 0x00, 0x02, // ADD R1 0x0002
  /* 0x038 */ 0x05, 0x01, 0x20, 0x04, // WRITE R1 MEM:0x004

  // continue the execution of the firmware from memory
  // for performance reasons
  // next instruction is firmare address + address of the
  // instruction next to the jump = MEM:020 + MEM:040
  /* 0x03C */ 0x11, 0x20, 0x60, 0x00, // JMP MEM:0x060

  // write device table in memory
  // RO: current memory address
  // R1: current device address
  // R2: current device type / comparison result
  // R3: bootable device
  /* 0x040 */ 0x01, 0x00, 0x20, 0x04, // MOV R0 MEM:0x006 - 2
  /* 0x044 */ 0x01, 0x01, 0x2f, 0xff, // MOV R1 0x3fff - 0x1000
  /* 0x048 */ 0x01, 0x03, 0x00, 0x00, // MOV R3 0x0000
  // LOOP START
  /* 0x04C */ 0x0B, 0x00, 0x00, 0x02, // ADD R0 0x0002
  /* 0x050 */ 0x0B, 0x01, 0x10, 0x00, // ADD R1 0x1000
  /* 0x054 */ 0x04, 0x02, 0x01, 0x00, // READ R2 R1
  /* 0x058 */ 0x06, 0x00, 0x02, 0x00, // WRITE R0 R2
  // If R3 is empty
  /* 0x05C */ 0x02, 0x02, 0x03, 0x00, // MOV R2 R3
  /* 0x060 */ 0x0F, 0x02, 0x00, 0x00, // CMP R2 0x0000
  /* 0x064 */ 0x14, 0x02, 0x20, 0x9C, // JNE R2 MEM:0x020 + MEM:0x07C
  // and if current device type is storage...
  /* 0x068 */ 0x04, 0x03, 0x00, 0x00, // READ R3 R0
  /* 0x06C */ 0x02, 0x02, 0x03, 0x00, // MOV R2 R3
  /* 0x070 */ 0x0F, 0x02, 0x00, 0x04, // CMP R2 0x0004
  /* 0x074 */ 0x14, 0x02, 0x20, 0x9C, // JNE R2 MEM:0x020 + MEM:0x07C
  // then store in R3 current device address
  /* 0x078 */ 0x02, 0x03, 0x01, 0x00, // MOV R3 R1
  // end if
  /* 0x07C */ 0x02, 0x02, 0x00, 0x00, // MOV R2 R0
  /* 0x080 */ 0x0F, 0x02, 0x20, 0x1E, // CMP R2 MEM:0x01E
  /* 0x084 */ 0x15, 0x02, 0x20, 0x6C, // JL R2 MEM:0x020 + MEM:0x04C

  // copy boot sector in memory
  // R3: current boot device address
  // R0: current memory address
  // R1: current boot device instruction / comparison result
  // R2: final address of boot sector
  // Calculate start of boot device address - 0x?002 considering that
  // the initial value is 0x?fff
  /* 0x088 */ 0x0D, 0x03, 0x10, 0x01, // SUB R3 0x1001
  // Initialize current memory address with boot sector address - 2
  /* 0x08C */ 0x03, 0x00, 0x20, 0x04, // READ R0 MEM:0x004
  /* 0x090 */ 0x0D, 0x00, 0x00, 0x02, // SUB R0 0x0002
  // Calculate final address of boot sector, which is 0x0100
  // after the start, plus the 2 that we are subtracting
  /* 0x094 */ 0x02, 0x02, 0x03, 0x00, // MOV R2 R3
  /* 0x098 */ 0x0B, 0x02, 0x01, 0x02, // ADD R2 0x0102
  // LOOP START
  /* 0x09C */ 0x0B, 0x00, 0x00, 0x02, // ADD R0 0x0002
  /* 0x0A0 */ 0x0B, 0x03, 0x00, 0x02, // ADD R3 0x0002
  // Read current boot device instruction
  /* 0x0A4 */ 0x04, 0x01, 0x03, 0x00, // READ R1 R3
  // Write current boot device instruction to memory
  /* 0x0A8 */ 0x06, 0x00, 0x01, 0x00, // WRITE R0 R1
  // If not last instruction loop
  /* 0x0AC */ 0x02, 0x01, 0x03, 0x00, // MOV R1 R3
  /* 0x0B0 */ 0x10, 0x01, 0x02, 0x00, // CMP R1 R2
  /* 0x0B4 */ 0x15, 0x01, 0x20, 0xBC, // JL R1 MEM:0x020 + MEM:0x09C

  // Go to boot sector of boot device
  /* 0x0B8 */ 0x03, 0x00, 0x20, 0x04, // READ R0 MEM:0x004
  /* 0x0BC */ 0x12, 0x00, 0x00, 0x00, // JMP R0
];
